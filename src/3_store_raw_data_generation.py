# -*- coding: utf-8 -*-
"""data_cleaning_raw_data

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vcSH2j1J5K7YJHK00EDTYALH1BAxNsn8
"""

# Installing important libraries & Importing from them.
!pip install rapidfuzz
!pip install --upgrade pip
!pip install rapidfuzz==3.6.1
import re
import pandas as pd
from rapidfuzz import fuzz
import random
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import AgglomerativeClustering
from sklearn.metrics.pairwise import cosine_similarity
!pip install flask pyngrok --quiet
from flask import Flask, render_template_string, request, redirect, url_for
from pyngrok import ngrok



# --- Install PostgreSQL & Python drivers ---
!apt-get -y update
!apt-get -y install postgresql postgresql-contrib
!pip install sqlalchemy psycopg[binary]

# --- Start PostgreSQL service ---
!service postgresql start

# --- Configure PostgreSQL (create user + DB) ---
# Default postgres user has no password; set your own here
PG_USER = "colab_user"
PG_PASS = "colab_pass"
PG_DB   = "colab_db"

# Create user and database
!sudo -u postgres psql -c "DROP DATABASE IF EXISTS {PG_DB};"
!sudo -u postgres psql -c "DROP ROLE IF EXISTS {PG_USER};"
!sudo -u postgres psql -c "CREATE ROLE {PG_USER} WITH LOGIN PASSWORD '{PG_PASS}';"
!sudo -u postgres psql -c "CREATE DATABASE {PG_DB} OWNER {PG_USER};"

# --- SQLAlchemy engine setup ---
from sqlalchemy import create_engine, text

engine = create_engine(
    f"postgresql+psycopg://{PG_USER}:{PG_PASS}@localhost:5432/{PG_DB}",
    echo=True
)
"""
Retail Item Master Project
File: 3_store_raw_data_generation.py

In this script I designed and generated synthetic, messy POS item data
for three different stores. I kept the brand and product logic consistent
internally, but I varied item names and categories across stores to simulate
real-world inconsistency in multi-store POS systems.
"""


# I defined a master product list with canonical item names, brands, categories and pack sizes.
PRODUCTS = [
    ("Coca Cola",           "Coca Cola",          "Beverages",   ["250ml", "300ml", "500ml", "1L"]),
    ("Pepsi",               "Pepsi",              "Beverages",   ["250ml", "300ml", "500ml", "600ml", "1L"]),
    ("Maggi Masala Noodles","Nestle",             "Food",        ["35g", "70g", "140g"]),
    ("Ariel Matic Powder",  "Procter & Gamble",   "Home Care",   ["500g", "1kg", "2kg"]),
    ("Dove Soap",           "Hindustan Unilever", "Toiletries",  ["50g", "75g", "100g"]),
]

# I flattened the canonical products into a SKU-level list so that each size became one SKU.
SKUS = []
for name, brand, category, sizes in PRODUCTS:
    for size in sizes:
        SKUS.append((name, brand, category, size))

# I created a store-wise category map to simulate different merchandising hierarchies.
CATEGORY_MAP = {
    "Store1": {
        "Beverages": "Beverages",
        "Food": "Instant Food",
        "Home Care": "Detergents",
        "Toiletries": "Personal Care",
    },
    "Store2": {
        "Beverages": "Soft Drinks",
        "Food": "Noodles & Soups",
        "Home Care": "Laundry Care",
        "Toiletries": "Bath & Body",
    },
    "Store3": {
        "Beverages": "Cold Drinks",
        "Food": "Food Items",
        "Home Care": "Home Essentials",
        "Toiletries": "Toiletries",
    },
}


def make_name(store: str, base_name: str, size: str) -> str:
    """
    I created store-specific item name variations for each base product,
    so that the same logical SKU looked different across stores.
    """
    variations = {
        "Coca Cola": {
            "Store1": f"CocaCola {size}",
            "Store2": f"Coke - {size}",
            "Store3": f"{size} Coca-Cola Classic",
        },
        "Pepsi": {
            "Store1": f"Pepsi {size}",
            "Store2": f"Pepsi Cola {size}",
            "Store3": f"{size} PEPSI",
        },
        "Maggi Masala Noodles": {
            "Store1": f"Maggi 2-Min Noodles Masala {size}",
            "Store2": f"Maggi Noodles - Masala {size}",
            "Store3": f"{size} Maggi Masala Noodles",
        },
        "Ariel Matic Powder": {
            "Store1": f"Ariel Matic Detergent Powder {size}",
            "Store2": f"Ariel Powder Matic - {size}",
            "Store3": f"{size} Ariel Matic Washing Powder",
        },
        "Dove Soap": {
            "Store1": f"Dove Beauty Cream Bar {size}",
            "Store2": f"Dove Moisturising Soap {size}",
            "Store3": f"Dove {size} Beauty Bar",
        },
    }

    product_variants = variations.get(base_name, {})
    return product_variants.get(store, f"{base_name} {size}")


def pos_code(store: str, index: int) -> str:
    """
    I defined a simple pattern to generate store-specific POS codes.
    """
    if store == "Store1":
        return f"1{str(1000 + index).zfill(4)}"
    if store == "Store2":
        return f"S2{str(2000 + index).zfill(4)}"
    if store == "Store3":
        return f"ST3-{str(3000 + index).zfill(4)}"
    raise ValueError(f"Unknown store: {store}")


def generate_store_data(store_name: str, num_transactions: int = 150) -> pd.DataFrame:
    """
    I generated a synthetic retail dataset for a single store.
    I kept brand values canonical but allowed item names and categories to vary by store.
    """
    rows = []
    for i in range(num_transactions):
        base_name, brand_canonical, canonical_category, size = random.choice(SKUS)

        # I built the store-specific item name here.
        item_name = make_name(store_name, base_name, size)

        # I kept display brand consistent with canonical brand.
        brand_display = brand_canonical

        # I mapped the canonical category to a store-specific category label.
        category_display = CATEGORY_MAP[store_name][canonical_category]

        # I assigned a store-specific POS code.
        pos = pos_code(store_name, i)

        rows.append(
            {
                "StoreID": store_name,
                "POSCode": pos,
                "ItemName": item_name,
                "Brand": brand_display,
                "PackSize": size,
                "Category": category_display,
            }
        )

    return pd.DataFrame(rows)


if __name__ == "__main__":
    # I fixed the random seed to make the generated data reproducible.
    random.seed(42)

    # I generated and saved data for all three stores.
    generate_store_data("Store1", 150).to_csv("Store1_Messy_Retail_Data.csv", index=False)
    generate_store_data("Store2", 150).to_csv("Store2_Messy_Retail_Data.csv", index=False)
    generate_store_data("Store3", 150).to_csv("Store3_Messy_Retail_Data.csv", index=False)

