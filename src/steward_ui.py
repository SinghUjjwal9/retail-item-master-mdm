# -*- coding: utf-8 -*-
"""data_cleaning_raw_data

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vcSH2j1J5K7YJHK00EDTYALH1BAxNsn8
"""

# Installing important libraries & Importing from them.
!pip install rapidfuzz
!pip install --upgrade pip
!pip install rapidfuzz==3.6.1
import re
import pandas as pd
from rapidfuzz import fuzz
import random
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import AgglomerativeClustering
from sklearn.metrics.pairwise import cosine_similarity
!pip install flask pyngrok --quiet
from flask import Flask, render_template_string, request, redirect, url_for
from pyngrok import ngrok

engine = create_engine("postgresql+psycopg2://postgres:mypassword@localhost:5432/postgres")


# --- Install PostgreSQL & Python drivers ---
!apt-get -y update
!apt-get -y install postgresql postgresql-contrib
!pip install sqlalchemy psycopg[binary]

# --- Start PostgreSQL service ---
!service postgresql start

# --- Configure PostgreSQL (create user + DB) ---
# Default postgres user has no password; set your own here
PG_USER = "colab_user"
PG_PASS = "colab_pass"
PG_DB   = "colab_db"

# Create user and database
!sudo -u postgres psql -c "DROP DATABASE IF EXISTS {PG_DB};"
!sudo -u postgres psql -c "DROP ROLE IF EXISTS {PG_USER};"
!sudo -u postgres psql -c "CREATE ROLE {PG_USER} WITH LOGIN PASSWORD '{PG_PASS}';"
!sudo -u postgres psql -c "CREATE DATABASE {PG_DB} OWNER {PG_USER};"

# --- SQLAlchemy engine setup ---
from sqlalchemy import create_engine, text

engine = create_engine(
    f"postgresql+psycopg://{PG_USER}:{PG_PASS}@localhost:5432/{PG_DB}",
    echo=True
)
# ============================================================
# SET NGROK AUTH TOKEN (REQUIRED)
# ============================================================
from pyngrok import conf
ngrok.set_auth_token("36EpvGefmjaAg8vUkTiTAA0S8mO_2BkXgecL63b6dkiHqVDTn")  # <-- put your token here


# ============================================================
# HTML TEMPLATES
# ============================================================

REVIEW_LIST_HTML = """
<!doctype html>
<html>
<head><title>Review Queue</title></head>
<body>
<h1>Pending Review Items</h1>

{% if items %}
<table border="1" cellpadding="5">
    <tr>
        <th>RawItemID</th>
        <th>Store</th>
        <th>ItemName</th>
        <th>Brand</th>
        <th>PackSize</th>
        <th>Category</th>
        <th>Suggested Master</th>
        <th>Confidence</th>
        <th>Action</th>
    </tr>
    {% for row in items %}
    <tr>
        <td>{{ row.RawItemID }}</td>
        <td>{{ row.Store_Name }}</td>
        <td>{{ row.ItemName }}</td>
        <td>{{ row.Brand }}</td>
        <td>{{ row.PackSize }}</td>
        <td>{{ row.Category }}</td>
        <td>{{ row.SuggestedMasterID }}</td>
        <td>{{ "%.3f" | format(row.ConfidenceScore) }}</td>
        <td>
            <a href="{{ url_for('review_detail', raw_item_id=row.RawItemID) }}">Review</a>
        </td>
    </tr>
    {% endfor %}
</table>
{% else %}
<p>No pending review items ðŸŽ‰</p>
{% endif %}

</body>
</html>
"""

REVIEW_DETAIL_HTML = """
<!doctype html>
<html>
<head><title>Review Item {{ item.RawItemID }}</title></head>
<body>

<h1>Review Item {{ item.RawItemID }}</h1>

<h2>Raw Item</h2>
<ul>
    <li><b>Store:</b> {{ item.Store_Name }}</li>
    <li><b>Store Item ID:</b> {{ item.Store_Item_ID }}</li>
    <li><b>ItemName:</b> {{ item.ItemName }}</li>
    <li><b>Brand:</b> {{ item.Brand }}</li>
    <li><b>PackSize:</b> {{ item.PackSize }}</li>
    <li><b>Category:</b> {{ item.Category }}</li>
    <li><b>Clean Name:</b> {{ item.clean_item_name }}</li>
    <li><b>Clean Brand:</b> {{ item.clean_brand }}</li>
    <li><b>Clean Pack:</b> {{ item.clean_pack_size }}</li>
    <li><b>Clean Category:</b> {{ item.clean_category }}</li>
    <li><b>Suggested MasterID:</b> {{ item.SuggestedMasterID }}</li>
    <li><b>Confidence:</b> {{ "%.3f" | format(item.ConfidenceScore) }}</li>
</ul>

{% if suggested_master %}
<h2>Suggested Master</h2>
<ul>
    <li><b>ID:</b> {{ suggested_master.MasterID }}</li>
    <li><b>Name:</b> {{ suggested_master.Master_Item_Name }}</li>
    <li><b>Brand:</b> {{ suggested_master.Master_Brand }}</li>
    <li><b>PackSize:</b> {{ suggested_master.Master_Pack_Size }}</li>
    <li><b>Category:</b> {{ suggested_master.Master_Category }}</li>
</ul>
{% else %}
<p>No suggested master for this item.</p>
{% endif %}

<hr>
<h2>Actions</h2>

<!-- Approve & Link -->
<h3>Approve & Link to Existing Master</h3>
<form method="post" action="{{ url_for('approve_link') }}">
    <input type="hidden" name="raw_item_id" value="{{ item.RawItemID }}">
    <label>Select Master:</label>
    <select name="master_id" required>
        {% if suggested_master %}
        <option value="{{ suggested_master.MasterID }}">
            [Suggested] {{ suggested_master.MasterID }} - {{ suggested_master.Master_Item_Name }}
        </option>
        {% endif %}
        {% for m in masters %}
        <option value="{{ m.MasterID }}">
            {{ m.MasterID }} - {{ m.Master_Item_Name }} ({{ m.Master_Brand }})
        </option>
        {% endfor %}
    </select>
    <button type="submit">Approve & Link</button>
</form>

<!-- Approve & Create New -->
<h3>Approve & Create New Master</h3>
<form method="post" action="{{ url_for('approve_create') }}">
    <input type="hidden" name="raw_item_id" value="{{ item.RawItemID }}">
    <button type="submit">Approve & Create</button>
</form>

<!-- Reject -->
<h3>Reject</h3>
<form method="post" action="{{ url_for('reject_item') }}">
    <input type="hidden" name="raw_item_id" value="{{ item.RawItemID }}">
    <button type="submit">Reject</button>
</form>

<br>
<a href="{{ url_for('review_list') }}">Back</a>

</body>
</html>
"""


# ============================================================
# FLASK APP
# ============================================================

app = Flask(__name__)


def row_to_obj(row):
    """Convert SQLAlchemy Row to a simple object with attributes for Jinja."""
    if row is None:
        return None
    d = dict(row._mapping)  # works for SQLAlchemy 1.4/2.x
    return type("RowObj", (), d)


def rows_to_objs(rows):
    return [row_to_obj(r) for r in rows]


# ---------- ROUTE: LIST PENDING ----------
@app.route("/")
@app.route("/review")
def review_list():
    with engine.connect() as conn:
        rows = conn.execute(text("""
            SELECT * FROM review_queue
            WHERE "Status" = 'Pending'
            ORDER BY "RawItemID"
            LIMIT 100;
        """)).fetchall()
    items = rows_to_objs(rows)
    return render_template_string(REVIEW_LIST_HTML, items=items)


# ---------- ROUTE: DETAIL ----------
@app.route("/review/<int:raw_item_id>")
def review_detail(raw_item_id):
    with engine.connect() as conn:
        row = conn.execute(text("""
            SELECT * FROM review_queue WHERE "RawItemID" = :rid
        """), {"rid": raw_item_id}).fetchone()

        if not row:
            return "Item not found", 404

        item = row_to_obj(row)

        suggested_master = None
        if getattr(item, "SuggestedMasterID", None) is not None:
            sm_row = conn.execute(text("""
                SELECT * FROM central_item_master
                WHERE "MasterID" = :mid
            """), {"mid": item.SuggestedMasterID}).fetchone()
            suggested_master = row_to_obj(sm_row) if sm_row else None

        m_rows = conn.execute(text("""
            SELECT "MasterID", "Master_Item_Name", "Master_Brand",
                   "Master_Pack_Size", "Master_Category"
            FROM central_item_master
            ORDER BY "MasterID"
            LIMIT 50;
        """)).fetchall()
        masters = rows_to_objs(m_rows)

    return render_template_string(
        REVIEW_DETAIL_HTML,
        item=item,
        suggested_master=suggested_master,
        masters=masters
    )


# ---------- ACTION: APPROVE & LINK ----------
@app.post("/action/approve_link")
def approve_link():
    raw_item_id = int(request.form["raw_item_id"])
    master_id = int(request.form["master_id"])

    with engine.begin() as conn:
        row = conn.execute(text("""
            SELECT * FROM review_queue WHERE "RawItemID" = :rid
        """), {"rid": raw_item_id}).fetchone()

        if not row:
            return "Item not found", 404

        item = dict(row._mapping)

        conn.execute(text("""
            INSERT INTO itemmapping
            ("RawItemID","MasterID","ConfidenceScore",
             "Store_Name","Store_Item_ID","POSCode",
             "ItemName","Brand","PackSize","Category",
             "clean_item_name","clean_brand","clean_pack_size","clean_category")
            VALUES (:raw,:mid,:conf,:sn,:sid,NULL,:name,:brand,:pack,:cat,:cname,:cbrand,:cpack,:ccat)
        """), {
            "raw": item["RawItemID"],
            "mid": master_id,
            "conf": item["ConfidenceScore"],
            "sn": item["Store_Name"],
            "sid": item["Store_Item_ID"],
            "name": item["ItemName"],
            "brand": item["Brand"],
            "pack": item["PackSize"],
            "cat": item["Category"],
            "cname": item["clean_item_name"],
            "cbrand": item["clean_brand"],
            "cpack": item["clean_pack_size"],
            "ccat": item["clean_category"]
        })

        conn.execute(text("""
            UPDATE central_item_master
            SET "RawItemsCount" = "RawItemsCount" + 1
            WHERE "MasterID" = :mid
        """), {"mid": master_id})

        conn.execute(text("""
            UPDATE review_queue
            SET "Status" = 'Approved_Link'
            WHERE "RawItemID" = :rid
        """), {"rid": raw_item_id})

    return redirect(url_for("review_list"))


# ---------- ACTION: APPROVE & CREATE ----------
@app.post("/action/approve_create")
def approve_create():
    raw_item_id = int(request.form["raw_item_id"])

    with engine.begin() as conn:
        row = conn.execute(text("""
            SELECT * FROM review_queue WHERE "RawItemID" = :rid
        """), {"rid": raw_item_id}).fetchone()

        if not row:
            return "Item not found", 404

        item = dict(row._mapping)

        max_mid = conn.execute(text("""
            SELECT COALESCE(MAX("MasterID"), 0) FROM central_item_master
        """)).scalar()
        new_id = max_mid + 1

        conn.execute(text("""
            INSERT INTO central_item_master
            ("MasterID","Master_Item_Name","Master_Brand",
             "Master_Pack_Size","Master_Category","RawItemsCount")
            VALUES (:mid,:name,:brand,:pack,:cat,1)
        """), {
            "mid": new_id,
            "name": item["clean_item_name"],
            "brand": item["clean_brand"],
            "pack": item["clean_pack_size"],
            "cat": item["clean_category"]
        })

        conn.execute(text("""
            INSERT INTO itemmapping
            ("RawItemID","MasterID","ConfidenceScore",
             "Store_Name","Store_Item_ID","POSCode",
             "ItemName","Brand","PackSize","Category",
             "clean_item_name","clean_brand","clean_pack_size","clean_category")
            VALUES (:raw,:mid,:conf,:sn,:sid,NULL,:name,:brand,:pack,:cat,:cname,:cbrand,:cpack,:ccat)
        """), {
            "raw": item["RawItemID"],
            "mid": new_id,
            "conf": item["ConfidenceScore"],
            "sn": item["Store_Name"],
            "sid": item["Store_Item_ID"],
            "name": item["ItemName"],
            "brand": item["Brand"],
            "pack": item["PackSize"],
            "cat": item["Category"],
            "cname": item["clean_item_name"],
            "cbrand": item["clean_brand"],
            "cpack": item["clean_pack_size"],
            "ccat": item["clean_category"]
        })

        conn.execute(text("""
            UPDATE review_queue
            SET "Status" = 'Approved_New'
            WHERE "RawItemID" = :rid
        """), {"rid": raw_item_id})

    return redirect(url_for("review_list"))


# ---------- ACTION: REJECT ----------
@app.post("/action/reject")
def reject_item():
    raw_item_id = int(request.form["raw_item_id"])

    with engine.begin() as conn:
        conn.execute(text("""
            UPDATE review_queue
            SET "Status" = 'Rejected'
            WHERE "RawItemID" = :rid
        """), {"rid": raw_item_id})

    return redirect(url_for("review_list"))


# ============================================================
# START FLASK + NGROK
# ============================================================

# Kill previous tunnels if any
ngrok.kill()

# Open tunnel
public_url = ngrok.connect(5000)
print("ðŸ”— Public URL:", public_url)

# Start Flask (debug=True shows detailed error if something breaks)
app.run(port=5000, debug=True, use_reloader=False)
